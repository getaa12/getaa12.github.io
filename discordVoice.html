<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØºÙŠØ± Ø£ØµÙˆØ§Øª Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap');
        body {
            font-family: 'Cairo', sans-serif;
            background-color: #313338;
        }
        .discord-btn { transition: all 0.2s; }
        .discord-btn:active { transform: scale(0.95); }
        .pulse { animation: pulse-animation 1.5s infinite; }
        @keyframes pulse-animation {
            0% { box-shadow: 0 0 0 0 rgba(235, 69, 158, 0.4); }
            70% { box-shadow: 0 0 0 15px rgba(235, 69, 158, 0); }
            100% { box-shadow: 0 0 0 0 rgba(235, 69, 158, 0); }
        }
        
        /* Custom Select Styling */
        .custom-select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23b5bac1%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: left 1rem center;
            background-size: 0.65em auto;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen text-gray-100 selection:bg-indigo-500 selection:text-white">

    <div class="w-full max-w-md bg-[#2b2d31] rounded-xl shadow-2xl overflow-hidden border border-[#1e1f22] p-6 text-center">
        
        <!-- Header -->
        <div class="mb-6">
            <h1 class="text-2xl font-bold text-gray-100 mb-2 flex items-center justify-center gap-2">
                <i class="fab fa-discord text-[#5865F2]"></i> Ù…ØºÙŠØ± Ø§Ù„Ø£ØµÙˆØ§Øª
            </h1>
            <p class="text-gray-400 text-sm">Ø³Ø¬Ù„ØŒ ØºÙŠÙ‘Ø± ØµÙˆØªÙƒØŒ ÙˆØ­Ù…Ù„Ù‡ Ù„Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯</p>
        </div>

        <!-- Effect Selector -->
        <div class="mb-6 relative">
            <label class="block text-right text-xs text-gray-400 mb-2 font-bold px-1">Ø§Ø®ØªØ± Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„ØµÙˆØªÙŠ:</label>
            <div class="relative">
                <select id="effectSelect" class="custom-select w-full bg-[#1e1f22] text-gray-200 p-3 pr-4 pl-10 rounded-lg outline-none border border-[#1e1f22] focus:border-[#5865F2] transition-colors cursor-pointer text-sm font-semibold">
                    <option value="none">ğŸ¤ ØµÙˆØª Ø·Ø¨ÙŠØ¹ÙŠ (Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±)</option>
                    <option value="woman">ğŸ‘© ØµÙˆØª Ù†Ø³Ø§Ø¦ÙŠ (Ù†ØºÙ…Ø© Ø¹Ø§Ù„ÙŠØ©)</option>
                    <option value="man">ğŸ‘¨ ØµÙˆØª Ø±Ø¬Ø§Ù„ÙŠ (Ù†ØºÙ…Ø© Ø¹Ù…ÙŠÙ‚Ø©)</option>
                    <option value="chipmunk">ğŸ¿ï¸ Ø³Ù†Ø¬Ø§Ø¨ (Ø³Ø±ÙŠØ¹ Ø¬Ø¯Ø§Ù‹)</option>
                    <option value="monster">ğŸ‘¹ ÙˆØ­Ø´ (Ø¨Ø·ÙŠØ¡ ÙˆÙ…Ø±Ø¹Ø¨)</option>
                    <option value="robot">ğŸ¤– Ø±ÙˆØ¨ÙˆØª (Ù…Ø¹Ø¯Ù†ÙŠ)</option>
                </select>
                <div class="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none text-[#5865F2]">
                    <i class="fas fa-magic"></i>
                </div>
            </div>
        </div>

        <!-- Timer -->
        <div id="timer" class="text-4xl font-mono font-bold text-gray-200 mb-8 tracking-wider">
            00:00
        </div>

        <!-- Visualizer -->
        <div class="h-16 w-full bg-[#1e1f22] rounded-lg mb-8 overflow-hidden relative flex items-center justify-center border border-[#111214]">
            <canvas id="visualizer"></canvas>
            <span id="placeholder-wave" class="text-gray-600 text-xs absolute">Ø§Ù„Ù…ÙˆØ¬Ø§Øª Ø§Ù„ØµÙˆØªÙŠØ© Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</span>
        </div>

        <!-- Controls -->
        <div class="flex justify-center items-center gap-4">
            <button id="recordBtn" class="discord-btn w-20 h-20 rounded-full bg-[#5865F2] hover:bg-[#4752C4] text-white text-2xl shadow-lg flex items-center justify-center focus:outline-none">
                <i class="fas fa-microphone"></i>
            </button>

            <button id="stopBtn" class="hidden discord-btn w-20 h-20 rounded-full bg-[#ED4245] hover:bg-[#c03537] text-white text-2xl shadow-lg flex items-center justify-center focus:outline-none pulse">
                <i class="fas fa-stop"></i>
            </button>
        </div>

        <p id="statusText" class="mt-6 text-gray-400 text-sm font-semibold">Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ³Ø¬ÙŠÙ„</p>

        <!-- Processing Indicator (Hidden) -->
        <div id="processingLoader" class="hidden mt-4">
            <i class="fas fa-circle-notch fa-spin text-[#5865F2] text-xl"></i>
            <span class="text-xs text-gray-400 block mt-1">Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØª...</span>
        </div>

    </div>

    <script>
        let audioContext;
        let mediaStream;
        let recorder;
        let input;
        let audioChunks = [];
        let startTime;
        let timerInterval;
        let analyser;
        let canvasContext;
        let animationId;
        const bufferSize = 4096;

        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusText = document.getElementById('statusText');
        const timerDisplay = document.getElementById('timer');
        const canvas = document.getElementById('visualizer');
        const placeholderWave = document.getElementById('placeholder-wave');
        const effectSelect = document.getElementById('effectSelect');
        const processingLoader = document.getElementById('processingLoader');

        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvasContext = canvas.getContext('2d');
            canvasContext.scale(dpr, dpr);
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
        }
        window.addEventListener('resize', setupCanvas);

        function updateTimer() {
            const now = Date.now();
            const diff = now - startTime;
            const seconds = Math.floor((diff / 1000) % 60);
            const minutes = Math.floor((diff / (1000 * 60)) % 60);
            timerDisplay.textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function drawVisualizer() {
            const WIDTH = canvas.width / (window.devicePixelRatio || 1);
            const HEIGHT = canvas.height / (window.devicePixelRatio || 1);
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            canvasContext.fillStyle = '#1e1f22';
            canvasContext.fillRect(0, 0, WIDTH, HEIGHT);

            const barWidth = (WIDTH / bufferLength) * 2.5;
            let barHeight;
            let x = 0;

            for(let i = 0; i < bufferLength; i++) {
                barHeight = dataArray[i] / 2;
                canvasContext.fillStyle = `rgb(${50 + barHeight}, ${101 + (barHeight/2)}, ${242})`;
                const y = (HEIGHT - barHeight) / 2;
                canvasContext.fillRect(x, y, barWidth, barHeight);
                x += barWidth + 1;
            }
            animationId = requestAnimationFrame(drawVisualizer);
        }

        async function startRecording() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 64;
                
                input = audioContext.createMediaStreamSource(mediaStream);
                input.connect(analyser);

                recorder = audioContext.createScriptProcessor(bufferSize, 1, 1);
                audioChunks = [];
                
                recorder.onaudioprocess = (e) => {
                    const channelData = e.inputBuffer.getChannelData(0);
                    audioChunks.push(new Float32Array(channelData));
                };

                input.connect(recorder);
                recorder.connect(audioContext.destination);

                setupCanvas();
                drawVisualizer();

                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 1000);
                
                recordBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                statusText.textContent = "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...";
                statusText.className = "mt-6 text-[#ED4245] text-sm font-semibold animate-pulse";
                placeholderWave.style.display = 'none';
                effectSelect.disabled = true; // Disable change while recording

            } catch (err) {
                console.error("Error:", err);
                alert("ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†.");
            }
        }

        async function stopRecording() {
            if (recorder && input) {
                recorder.disconnect();
                input.disconnect();
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            clearInterval(timerInterval);
            cancelAnimationFrame(animationId);
            
            // UI Updates
            stopBtn.classList.add('hidden');
            processingLoader.classList.remove('hidden');
            statusText.textContent = "Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª...";
            
            // Wait a moment for UI to update
            setTimeout(async () => {
                const selectedEffect = effectSelect.value;
                const processedBuffer = await applyEffect(audioChunks, selectedEffect);
                
                exportWAV(processedBuffer);

                // Reset UI
                canvasContext.clearRect(0, 0, canvas.width, canvas.height);
                placeholderWave.style.display = 'block';
                recordBtn.classList.remove('hidden');
                processingLoader.classList.add('hidden');
                effectSelect.disabled = false;
                statusText.textContent = "ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„! Ø§Ø³Ø­Ø¨Ù‡ Ù„Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯";
                statusText.className = "mt-6 text-[#23a559] text-sm font-semibold";
                timerDisplay.textContent = "00:00";
            }, 100);
        }

        // --- Audio Effect Processing ---
        async function applyEffect(chunks, effect) {
            // 1. Convert raw chunks to a single AudioBuffer
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const rawBuffer = audioContext.createBuffer(1, totalLength, audioContext.sampleRate);
            const channelData = rawBuffer.getChannelData(0);
            let offset = 0;
            for (const chunk of chunks) {
                channelData.set(chunk, offset);
                offset += chunk.length;
            }

            if (effect === 'none') return channelData;

            // 2. Setup Offline Context for rendering effects
            // Determine new duration (pitch shifting usually changes speed)
            let speedRate = 1.0;
            if (effect === 'woman') speedRate = 1.15; // Faster/Higher
            if (effect === 'man') speedRate = 0.85;   // Slower/Deeper
            if (effect === 'chipmunk') speedRate = 1.5; 
            if (effect === 'monster') speedRate = 0.65;
            
            const newLength = Math.ceil(totalLength / speedRate);
            const offlineCtx = new OfflineAudioContext(1, newLength, audioContext.sampleRate);
            
            const source = offlineCtx.createBufferSource();
            source.buffer = rawBuffer;

            // Apply Effects
            if (effect === 'robot') {
                // Ring Modulation Effect
                const oscillator = offlineCtx.createOscillator();
                oscillator.frequency.value = 50; // Metal frequency
                oscillator.type = 'sawtooth';
                
                const gainOsc = offlineCtx.createGain();
                gainOsc.gain.value = 1000;

                const gainNode = offlineCtx.createGain();
                gainNode.gain.value = 0.5;

                // Modulate gain
                oscillator.connect(gainNode.gain);
                source.connect(gainNode);
                gainNode.connect(offlineCtx.destination);
                oscillator.start();
            } else {
                // Pitch/Speed shifting
                source.playbackRate.value = speedRate;
                
                if (effect === 'monster') {
                    // Add distortion
                    const waveShaper = offlineCtx.createWaveShaper();
                    waveShaper.curve = makeDistortionCurve(400);
                    source.connect(waveShaper);
                    waveShaper.connect(offlineCtx.destination);
                } else {
                    source.connect(offlineCtx.destination);
                }
            }

            source.start();
            
            // Render
            const renderedBuffer = await offlineCtx.startRendering();
            return renderedBuffer.getChannelData(0);
        }

        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                const x = (i * 2) / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        // --- WAV Encoding ---
        function exportWAV(data) {
            const buffer = new ArrayBuffer(44 + data.length * 2);
            const view = new DataView(buffer);

            // RIFF chunk
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + data.length * 2, true);
            writeString(view, 8, 'WAVE');
            
            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); 
            view.setUint16(22, 1, true); 
            view.setUint32(24, audioContext.sampleRate, true);
            view.setUint32(28, audioContext.sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true); 

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, data.length * 2, true);

            floatTo16BitPCM(view, 44, data);

            const blob = new Blob([view], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            
            // Filename based on effect
            const effectName = effectSelect.value !== 'none' ? `-${effectSelect.value}` : '';
            const date = new Date();
            const timestamp = `${date.getHours()}-${date.getMinutes()}`;
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `voice${effectName}-${timestamp}.wav`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function floatTo16BitPCM(output, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        recordBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
    </script>
</body>
</html>
